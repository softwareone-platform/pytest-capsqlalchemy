{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pytest-capsqlalchemy","text":"<p>Pytest plugin to allow capturing SQLAlchemy queries.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>Install <code>pytest-capsqlalchemy</code> via <code>pip</code> or your preferred package manager:</p> <pre><code>pip install pytest-capsqlalchemy\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>In order to use the fixtures provided by the plugin you also need to define a <code>db_engine</code> fixture in your <code>conftest.py</code>. This fixture should return an <code>AsyncEngine</code> instance. For example:</p> conftest.py<pre><code>import pytest\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\n\n@pytest.fixture(scope=\"session\")\ndef db_engine() -&gt; AsyncEngine:\n    return create_async_engine(\"postgresql+asyncpg://user:pass@localhost:5432/db\")\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#counting-number-of-queries","title":"Counting number of queries","text":"<p>Here is a basic example with asserts on the number of queries being performed</p> <pre><code>async def test_query_count(db_session, capsqlalchemy):\n    await db_session.execute(text(\"SELECT 1\"))\n\n    capsqlalchemy.assert_query_count(1, include_tcl=False)  # (1)!\n    capsqlalchemy.assert_query_count(3, include_tcl=True)   # (2)!\n</code></pre> <ol> <li>The <code>capsqlfixture</code> starts recording the queries which are sent to the database at the beginning of the test.    As TCL statements (<code>BEGIN</code>, <code>COMMIT</code>, <code>ROLLBACK</code>) are not included in this assert, only <code>SELECT 1</code> is counted</li> <li>This time TCL statements are being counted and since by default SQLAlchemy is configured in <code>autobegin</code> mode,    there are 3 queries which are being counted: <code>BEGIN</code>, <code>SELECT 1</code> and <code>ROLLBACK</code></li> </ol>"},{"location":"#capturing-queries-in-specific-context","title":"Capturing queries in specific context","text":"<p>You can also use <code>capqsqlalchemy</code> as a context manager to check only for the queries being performed in a specific section of your code. For example:</p> <pre><code>async def test_context(db_session, capsqlalchemy):\n    capsqlalchemy.assert_query_count(0, include_tcl=False)      # (1)!\n\n    await db_session.execute(text(\"SELECT 1\"))\n    capsqlalchemy.assert_query_count(1, include_tcl=False)      # (2)!\n\n    with capsqlalchemy:\n        await db_session.execute(text(\"SELECT 2\"))\n        await db_session.execute(text(\"SELECT 3\"))\n        capsqlalchemy.assert_query_count(2, include_tcl=False)  # (3)!\n\n    capsqlalchemy.assert_query_count(3, include_tcl=False)      # (4)!\n</code></pre> <ol> <li>No queries have been executed yet</li> <li>Just like in the previous example only <code>SELECT 1</code> has been captured yet</li> <li>Since the assert is being performed inside the <code>with</code> block only <code>SELECT 2</code> and <code>SELECT 3</code> will be counted</li> <li>When using a context manager, the outer scope still counts the inner scope queries, so this time all    <code>SELECT 1</code>, <code>SELECT 2</code> and <code>SELECT 3</code> are captured</li> </ol>"},{"location":"#checking-exact-queries","title":"Checking exact queries","text":"<p>You can also write tests that the exact query you expected was generated and exectured by SQLALchemy. Here's an example with SQLAlchemy 2.0 ORM:</p> <pre><code>async def test_exact_query(db_session, capsqlalchemy):\n    await db_session.execute(select(Order.recipient).where(Order.id == 123))\n\n    capsqlalchemy.assert_captured_queries(  # (1)!\n        \"SELECT orders.id, orders.recipient \\nFROM orders \\nWHERE orders.id = :id_1\",\n        include_tcl=False,\n    )\n\n    capsqlalchemy.assert_captured_queries(  # (2)!\n        \"SELECT orders.id, orders.recipient \\nFROM orders \\nWHERE orders.id = 123\",\n        bind_params=True,\n        include_tcl=False,\n    )\n</code></pre> <ol> <li>By default the of the queries will not be binded, so <code>123</code> is replaced with <code>:id_1</code></li> <li>If we want to check that the query is exactly what we expected we can pass    <code>bind_params=True</code> and we'll get the full query</li> </ol>"},{"location":"#checking-the-query-types","title":"Checking the query types","text":"<p>There are also cases where we care about the queries being performed beyond just their count but we don't care about their structure in such a detail -- that's where we can check that the captured query types are are what we expect:</p> <pre><code>from pytest_capsqlalchemy import SQLExpressionType\n\nasync def test_query_types(db_session, capsqlalchemy):\n    await db_session.execute(select(Order))\n\n    await db_session.commit()\n\n    async with db_session.begin():\n        await db_session.execute(select(Order).where(Order.id == 123))\n        await db_session.execute(select(text(\"1\")))\n\n        db_session.add(Order(recipient=\"John Doe\"))\n\n    capsqlalchemy.assert_query_types(   # (1)!\n        SQLExpressionType.BEGIN,\n        SQLExpressionType.SELECT,\n        SQLExpressionType.COMMIT,\n        SQLExpressionType.BEGIN,\n        SQLExpressionType.SELECT,\n        SQLExpressionType.SELECT,\n        SQLExpressionType.INSERT,\n        SQLExpressionType.COMMIT,\n    )\n\n    capsqlalchemy.assert_query_types(  # (2)!\n        \"SELECT\",  # (3)!\n        \"SELECT\",\n        \"SELECT\",\n        \"INSERT\",\n        include_tcl=False,\n    )\n</code></pre> <ol> <li><code>assert_query_types</code> allows us to check that the captured queries are a <code>BEGIN</code>, a <code>SELECT</code>, a <code>COMMIT</code> etc. without    specifying their exact structure</li> <li>Similarly to the other assertion methods, we can exclude the TCL statements if we don't care about them</li> <li>We can also use strings instead of enum values to make the assert shorter to write</li> </ol> <p>Warning</p> <p>The order of the arguments matters -- it's the same order that the queries have been captured in.</p> <p>For example, with the following setup:</p> <pre><code>await db_session.execute(select(Order))\ndb_session.add(Order(recipient=\"John Doe\"))\n</code></pre> <p>this will pass:</p> <pre><code>capsqlalchemy.assert_query_types(\"SELECT\", \"INSERT\", include_tcl=False)\n</code></pre> <p>but this will fail:</p> <pre><code>capsqlalchemy.assert_query_types(\"INSERT\", \"SELECT\", include_tcl=False)\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#pytest_capsqlalchemy.plugin.capsqlalchemy_context","title":"capsqlalchemy_context","text":"<pre><code>capsqlalchemy_context(\n    db_engine: AsyncEngine,\n) -&gt; Generator[SQLAlchemyCaptureContext]\n</code></pre> <p>The main fixture to get the <code>SQLAlchemyCaptureContext</code>.</p> <p>This is the context for the full test, which captures all SQL expressions executed during the test.</p> <p>To capture only the SQL expressions executed within a specific block, use the <code>capsqlalchemy</code> fixture.</p> Source code in <code>pytest_capsqlalchemy/plugin.py</code> <pre><code>@pytest.fixture\ndef capsqlalchemy_context(db_engine: AsyncEngine) -&gt; Generator[SQLAlchemyCaptureContext]:\n    \"\"\"The main fixture to get the [`SQLAlchemyCaptureContext`][pytest_capsqlalchemy.context.SQLAlchemyCaptureContext].\n\n    This is the context for the full test, which captures all SQL expressions executed during the test.\n\n    To capture only the SQL expressions executed within a specific block, use the\n    [`capsqlalchemy`][pytest_capsqlalchemy.plugin.capsqlalchemy] fixture.\n    \"\"\"\n    with SQLAlchemyCaptureContext(db_engine) as capsqlalchemy_ctx:\n        yield capsqlalchemy_ctx\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.plugin.capsqlalchemy","title":"capsqlalchemy","text":"<pre><code>capsqlalchemy(\n    capsqlalchemy_context: SQLAlchemyCaptureContext,\n) -&gt; SQLAlchemyCapturer\n</code></pre> <p>The main fixture to get the <code>SQLAlchemyCapturer</code>.</p> <p>Example Usage:</p> <pre><code>async def test_some_sql_queries(db_session, capsqlalchemy):\n    await db_session.execute(select(text(\"1\")))\n    capsqlalchemy.assert_query_count(1, include_tcl=False)\n\n    async with capsqlalchemy:\n        await db_session.execute(select(text(\"2\")))\n        await db_session.execute(select(text(\"3\")))\n        capsqlalchemy.assert_query_count(2, include_tcl=False)\n\n    capsqlalchemy.assert_query_count(3, include_tcl=False)\n</code></pre> <p>Returns:</p> Type Description <code>SQLAlchemyCapturer</code> <p>The capturer object with the full test context already set up.</p> Source code in <code>pytest_capsqlalchemy/plugin.py</code> <pre><code>@pytest.fixture()\ndef capsqlalchemy(capsqlalchemy_context: SQLAlchemyCaptureContext) -&gt; SQLAlchemyCapturer:\n    \"\"\"The main fixture to get the [`SQLAlchemyCapturer`][pytest_capsqlalchemy.capturer.SQLAlchemyCapturer].\n\n    Example Usage:\n\n    ```python\n    async def test_some_sql_queries(db_session, capsqlalchemy):\n        await db_session.execute(select(text(\"1\")))\n        capsqlalchemy.assert_query_count(1, include_tcl=False)\n\n        async with capsqlalchemy:\n            await db_session.execute(select(text(\"2\")))\n            await db_session.execute(select(text(\"3\")))\n            capsqlalchemy.assert_query_count(2, include_tcl=False)\n\n        capsqlalchemy.assert_query_count(3, include_tcl=False)\n    ```\n\n    Returns:\n        The capturer object with the full test context already set up.\n    \"\"\"\n    return SQLAlchemyCapturer(capsqlalchemy_context)\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer","title":"SQLAlchemyCapturer","text":"<p>The main fixture class for the <code>capsqlalchemy</code> plugin.</p> <p>Used to perform asserts about the expressions SQLAlchemy has executed during the test.</p> <p>Can be used either directly using the assert methods (to perform checks for all expressions executed in the test), as a context manager (to perform checks only for the expressions executed in a specific block), or a combination of both.</p> <p>Intended to be used via the <code>capsqlalchemy</code> fixture</p> Source code in <code>pytest_capsqlalchemy/capturer.py</code> <pre><code>class SQLAlchemyCapturer:\n    \"\"\"The main fixture class for the `capsqlalchemy` plugin.\n\n    Used to perform asserts about the expressions SQLAlchemy has executed during the test.\n\n    Can be used either directly using the assert methods (to perform checks for all expressions\n    executed in the test), as a context manager (to perform checks only for the expressions\n    executed in a specific block), or a combination of both.\n\n    Intended to be used via the [`capsqlalchemy`][pytest_capsqlalchemy.plugin.capsqlalchemy] fixture\n    \"\"\"\n\n    _full_test_context: SQLAlchemyCaptureContext\n    _partial_context: Optional[SQLAlchemyCaptureContext]\n\n    def __init__(self, full_test_context: SQLAlchemyCaptureContext):\n        \"\"\"Create a new SQLAlchemyCapturer instance.\"\"\"\n        self._full_test_context = full_test_context\n        self._partial_context = None\n\n    @property\n    def engine(self) -&gt; AsyncEngine:\n        \"\"\"The SQLAlchemy engine instance being captured.\"\"\"\n        return self._full_test_context._engine\n\n    @property\n    def captured_expressions(self) -&gt; list[SQLExpression]:\n        \"\"\"Returns all SQL expressions captured in the current context.\n\n        When used outside a context manager block, returns all expressions captured\n        during the entire test. When used inside a context manager block, returns\n        only the expressions captured within that specific block.\n\n        This property is useful for performing specific assertions on the captured expressions which\n        cannot be easily achieved with the provided assert methods.\n        \"\"\"\n        if self._partial_context is not None:\n            return self._partial_context.captured_expressions\n\n        return self._full_test_context.captured_expressions\n\n    def __enter__(self) -&gt; Self:\n        self._partial_context = SQLAlchemyCaptureContext(self.engine)\n        self._partial_context = self._partial_context.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exc_tb: Optional[TracebackType] = None,\n    ) -&gt; Optional[bool]:\n        if self._partial_context is None:  # pragma: no cover\n            raise RuntimeError(f\"{self.__class__.__name__}: attempting to call __exit__ before __enter__\")\n\n        result = self._partial_context.__exit__(exc_type, exc_val, exc_tb)\n\n        self._partial_context = None\n\n        return result\n\n    def assert_query_types(\n        self,\n        *expected_query_types: Union[SQLExpressionType, str],\n        include_tcl: bool = True,\n    ) -&gt; None:\n        \"\"\"Asserts that the captured SQL expressions match the expected query types in order.\n\n        This is useful for ensuring that your code is generating correct query types but\n        their exact structure is not important (e.g. complex SELECT statements).\n\n        Args:\n            *expected_query_types: Variable number of expected query types\n            include_tcl: Whether to include transaction control language statements (BEGIN,\n                COMMIT, ROLLBACK) in the comparison\n\n        Raises:\n            AssertionError: If the actual query types don't match the expected ones.\n        \"\"\"\n        actual_query_types_values = []\n\n        for query in self.captured_expressions:\n            if not include_tcl and query.type.is_tcl:\n                continue\n\n            actual_query_types_values.append(query.type._value_)\n\n        # Converting to strings as the error message diff will be shorter and more readable\n        expected_query_types_values = [\n            query_type._value_ if isinstance(query_type, SQLExpressionType) else query_type\n            for query_type in expected_query_types\n        ]\n\n        assert expected_query_types_values == actual_query_types_values\n\n    def assert_query_count(self, expected_query_count: int, *, include_tcl: bool = True) -&gt; None:\n        \"\"\"Asserts that the number of captured SQL expressions matches the expected count.\n\n        This is useful for ensuring that your code is not generating more statements than expected\n        (e.g. due to N+1 queries), however the exact queries are not important.\n\n        Args:\n            expected_query_count: The expected number of SQL expressions.\n            include_tcl: Whether to include transaction control language statements (BEGIN,\n                COMMIT, ROLLBACK) in the count.\n\n        Raises:\n            AssertionError: If the actual query count doesn't match the expected count.\n        \"\"\"\n        actual_query_count = sum(1 for query in self.captured_expressions if include_tcl or not query.type.is_tcl)\n\n        assert expected_query_count == actual_query_count, (\n            f\"Query count mismatch: expected {expected_query_count}, got {actual_query_count}\"\n        )\n\n    def assert_max_query_count(self, expected_max_query_count: int, *, include_tcl: bool = True) -&gt; None:\n        \"\"\"Asserts that the number of captured SQL expressions doesn't exceed the expected count.\n\n        This is useful for ensuring that your code is not generating more statements than expected\n        (e.g. due to N+1 queries), however the exact number of queries is not important -- for example\n        SQLAlchemy's caching mechanism may generate fewer queries than expected.\n\n        Args:\n            expected_max_query_count: The expected maximum number of SQL expressions.\n            include_tcl: Whether to include transaction control language statements (BEGIN,\n                COMMIT, ROLLBACK) in the count.\n\n        Raises:\n            AssertionError: If the actual query count exceeds the expected maximum count.\n        \"\"\"\n        actual_query_count = sum(1 for query in self.captured_expressions if include_tcl or not query.type.is_tcl)\n\n        assert expected_max_query_count &lt; actual_query_count, (\n            f\"Query count mismatch: expected maximum {expected_max_query_count}, got {actual_query_count}\"\n        )\n\n    def assert_captured_queries(\n        self,\n        *expected_queries: str,\n        include_tcl: bool = True,\n        bind_params: bool = False,\n    ) -&gt; None:\n        \"\"\"Asserts that the captured SQL queries match the expected SQL strings in order.\n\n        This is useful for ensuring that your code is generating the exact SQL statements you expect.\n\n        Args:\n            *expected_queries: Variable number of expected SQL query strings.\n            include_tcl: Whether to include transaction control language statements (BEGIN,\n                COMMIT, ROLLBACK) in the comparison.\n            bind_params: Whether to include bound parameters in the SQL strings. When `False`,\n                parameters are represented as placeholders instead.\n\n        Raises:\n            AssertionError: If the actual SQL queries don't match the expected ones.\n        \"\"\"\n        actual_queries = []\n\n        for query in self.captured_expressions:\n            if not include_tcl and query.type.is_tcl:\n                continue\n\n            actual_queries.append(query.get_sql(bind_params=bind_params))\n\n        assert list(expected_queries) == actual_queries\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.engine","title":"engine  <code>property</code>","text":"<pre><code>engine: AsyncEngine\n</code></pre> <p>The SQLAlchemy engine instance being captured.</p>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.captured_expressions","title":"captured_expressions  <code>property</code>","text":"<pre><code>captured_expressions: list[SQLExpression]\n</code></pre> <p>Returns all SQL expressions captured in the current context.</p> <p>When used outside a context manager block, returns all expressions captured during the entire test. When used inside a context manager block, returns only the expressions captured within that specific block.</p> <p>This property is useful for performing specific assertions on the captured expressions which cannot be easily achieved with the provided assert methods.</p>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.__init__","title":"__init__","text":"<pre><code>__init__(full_test_context: SQLAlchemyCaptureContext)\n</code></pre> <p>Create a new SQLAlchemyCapturer instance.</p> Source code in <code>pytest_capsqlalchemy/capturer.py</code> <pre><code>def __init__(self, full_test_context: SQLAlchemyCaptureContext):\n    \"\"\"Create a new SQLAlchemyCapturer instance.\"\"\"\n    self._full_test_context = full_test_context\n    self._partial_context = None\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.assert_query_types","title":"assert_query_types","text":"<pre><code>assert_query_types(\n    *expected_query_types: Union[SQLExpressionType, str],\n    include_tcl: bool = True,\n) -&gt; None\n</code></pre> <p>Asserts that the captured SQL expressions match the expected query types in order.</p> <p>This is useful for ensuring that your code is generating correct query types but their exact structure is not important (e.g. complex SELECT statements).</p> <p>Parameters:</p> Name Type Description Default <code>*expected_query_types</code> <code>Union[SQLExpressionType, str]</code> <p>Variable number of expected query types</p> <code>()</code> <code>include_tcl</code> <code>bool</code> <p>Whether to include transaction control language statements (BEGIN, COMMIT, ROLLBACK) in the comparison</p> <code>True</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the actual query types don't match the expected ones.</p> Source code in <code>pytest_capsqlalchemy/capturer.py</code> <pre><code>def assert_query_types(\n    self,\n    *expected_query_types: Union[SQLExpressionType, str],\n    include_tcl: bool = True,\n) -&gt; None:\n    \"\"\"Asserts that the captured SQL expressions match the expected query types in order.\n\n    This is useful for ensuring that your code is generating correct query types but\n    their exact structure is not important (e.g. complex SELECT statements).\n\n    Args:\n        *expected_query_types: Variable number of expected query types\n        include_tcl: Whether to include transaction control language statements (BEGIN,\n            COMMIT, ROLLBACK) in the comparison\n\n    Raises:\n        AssertionError: If the actual query types don't match the expected ones.\n    \"\"\"\n    actual_query_types_values = []\n\n    for query in self.captured_expressions:\n        if not include_tcl and query.type.is_tcl:\n            continue\n\n        actual_query_types_values.append(query.type._value_)\n\n    # Converting to strings as the error message diff will be shorter and more readable\n    expected_query_types_values = [\n        query_type._value_ if isinstance(query_type, SQLExpressionType) else query_type\n        for query_type in expected_query_types\n    ]\n\n    assert expected_query_types_values == actual_query_types_values\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.assert_query_count","title":"assert_query_count","text":"<pre><code>assert_query_count(\n    expected_query_count: int, *, include_tcl: bool = True\n) -&gt; None\n</code></pre> <p>Asserts that the number of captured SQL expressions matches the expected count.</p> <p>This is useful for ensuring that your code is not generating more statements than expected (e.g. due to N+1 queries), however the exact queries are not important.</p> <p>Parameters:</p> Name Type Description Default <code>expected_query_count</code> <code>int</code> <p>The expected number of SQL expressions.</p> required <code>include_tcl</code> <code>bool</code> <p>Whether to include transaction control language statements (BEGIN, COMMIT, ROLLBACK) in the count.</p> <code>True</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the actual query count doesn't match the expected count.</p> Source code in <code>pytest_capsqlalchemy/capturer.py</code> <pre><code>def assert_query_count(self, expected_query_count: int, *, include_tcl: bool = True) -&gt; None:\n    \"\"\"Asserts that the number of captured SQL expressions matches the expected count.\n\n    This is useful for ensuring that your code is not generating more statements than expected\n    (e.g. due to N+1 queries), however the exact queries are not important.\n\n    Args:\n        expected_query_count: The expected number of SQL expressions.\n        include_tcl: Whether to include transaction control language statements (BEGIN,\n            COMMIT, ROLLBACK) in the count.\n\n    Raises:\n        AssertionError: If the actual query count doesn't match the expected count.\n    \"\"\"\n    actual_query_count = sum(1 for query in self.captured_expressions if include_tcl or not query.type.is_tcl)\n\n    assert expected_query_count == actual_query_count, (\n        f\"Query count mismatch: expected {expected_query_count}, got {actual_query_count}\"\n    )\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.assert_max_query_count","title":"assert_max_query_count","text":"<pre><code>assert_max_query_count(\n    expected_max_query_count: int,\n    *,\n    include_tcl: bool = True,\n) -&gt; None\n</code></pre> <p>Asserts that the number of captured SQL expressions doesn't exceed the expected count.</p> <p>This is useful for ensuring that your code is not generating more statements than expected (e.g. due to N+1 queries), however the exact number of queries is not important -- for example SQLAlchemy's caching mechanism may generate fewer queries than expected.</p> <p>Parameters:</p> Name Type Description Default <code>expected_max_query_count</code> <code>int</code> <p>The expected maximum number of SQL expressions.</p> required <code>include_tcl</code> <code>bool</code> <p>Whether to include transaction control language statements (BEGIN, COMMIT, ROLLBACK) in the count.</p> <code>True</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the actual query count exceeds the expected maximum count.</p> Source code in <code>pytest_capsqlalchemy/capturer.py</code> <pre><code>def assert_max_query_count(self, expected_max_query_count: int, *, include_tcl: bool = True) -&gt; None:\n    \"\"\"Asserts that the number of captured SQL expressions doesn't exceed the expected count.\n\n    This is useful for ensuring that your code is not generating more statements than expected\n    (e.g. due to N+1 queries), however the exact number of queries is not important -- for example\n    SQLAlchemy's caching mechanism may generate fewer queries than expected.\n\n    Args:\n        expected_max_query_count: The expected maximum number of SQL expressions.\n        include_tcl: Whether to include transaction control language statements (BEGIN,\n            COMMIT, ROLLBACK) in the count.\n\n    Raises:\n        AssertionError: If the actual query count exceeds the expected maximum count.\n    \"\"\"\n    actual_query_count = sum(1 for query in self.captured_expressions if include_tcl or not query.type.is_tcl)\n\n    assert expected_max_query_count &lt; actual_query_count, (\n        f\"Query count mismatch: expected maximum {expected_max_query_count}, got {actual_query_count}\"\n    )\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.capturer.SQLAlchemyCapturer.assert_captured_queries","title":"assert_captured_queries","text":"<pre><code>assert_captured_queries(\n    *expected_queries: str,\n    include_tcl: bool = True,\n    bind_params: bool = False,\n) -&gt; None\n</code></pre> <p>Asserts that the captured SQL queries match the expected SQL strings in order.</p> <p>This is useful for ensuring that your code is generating the exact SQL statements you expect.</p> <p>Parameters:</p> Name Type Description Default <code>*expected_queries</code> <code>str</code> <p>Variable number of expected SQL query strings.</p> <code>()</code> <code>include_tcl</code> <code>bool</code> <p>Whether to include transaction control language statements (BEGIN, COMMIT, ROLLBACK) in the comparison.</p> <code>True</code> <code>bind_params</code> <code>bool</code> <p>Whether to include bound parameters in the SQL strings. When <code>False</code>, parameters are represented as placeholders instead.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the actual SQL queries don't match the expected ones.</p> Source code in <code>pytest_capsqlalchemy/capturer.py</code> <pre><code>def assert_captured_queries(\n    self,\n    *expected_queries: str,\n    include_tcl: bool = True,\n    bind_params: bool = False,\n) -&gt; None:\n    \"\"\"Asserts that the captured SQL queries match the expected SQL strings in order.\n\n    This is useful for ensuring that your code is generating the exact SQL statements you expect.\n\n    Args:\n        *expected_queries: Variable number of expected SQL query strings.\n        include_tcl: Whether to include transaction control language statements (BEGIN,\n            COMMIT, ROLLBACK) in the comparison.\n        bind_params: Whether to include bound parameters in the SQL strings. When `False`,\n            parameters are represented as placeholders instead.\n\n    Raises:\n        AssertionError: If the actual SQL queries don't match the expected ones.\n    \"\"\"\n    actual_queries = []\n\n    for query in self.captured_expressions:\n        if not include_tcl and query.type.is_tcl:\n            continue\n\n        actual_queries.append(query.get_sql(bind_params=bind_params))\n\n    assert list(expected_queries) == actual_queries\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.context.SQLAlchemyCaptureContext","title":"SQLAlchemyCaptureContext","text":"<p>Captures expressions executed on a SQLAlchemy engine within a specific context.</p> <p>These expressions include:</p> <pre><code>* SELECT\n* INSERT\n* UPDATE\n* DELETE\n* BEGIN\n* COMMIT\n* ROLLBACK\n</code></pre> <p>Every expression is captured as a SQLExpression object, allowing it to be parsed correctly and compared against.</p> <p>See <code>SQLAlchemyCapturer</code> for the available assertions on the captured expressions.</p> Source code in <code>pytest_capsqlalchemy/context.py</code> <pre><code>class SQLAlchemyCaptureContext:\n    \"\"\"Captures expressions executed on a SQLAlchemy engine within a specific context.\n\n    These expressions include:\n\n        * SELECT\n        * INSERT\n        * UPDATE\n        * DELETE\n        * BEGIN\n        * COMMIT\n        * ROLLBACK\n\n    Every expression is captured as a SQLExpression object, allowing it to be parsed correctly\n    and compared against.\n\n    See [`SQLAlchemyCapturer`][pytest_capsqlalchemy.capturer.SQLAlchemyCapturer] for the available\n    assertions on the captured expressions.\n    \"\"\"\n\n    _engine: AsyncEngine\n    _captured_expressions: list[SQLExpression]\n\n    def __init__(self, engine: AsyncEngine):\n        \"\"\"Create a new SQLAlchemyCaptureContext instance.\"\"\"\n        self._engine = engine\n        self._captured_expressions = []\n        self._sqlaclhemy_events_stack = contextlib.ExitStack()\n\n    @property\n    def captured_expressions(self) -&gt; list[SQLExpression]:\n        \"\"\"Returns all SQL expressions captured in the current context.\"\"\"\n        return self._captured_expressions\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all SQL expressions captured so far in the current context.\"\"\"\n        self._captured_expressions = []\n\n    def _on_begin(self, conn: Connection) -&gt; None:\n        self._captured_expressions.append(SQLExpression(executable=text(\"BEGIN\")))\n\n    def _on_commit(self, conn: Connection) -&gt; None:\n        self._captured_expressions.append(SQLExpression(executable=text(\"COMMIT\")))\n\n    def _on_rollback(self, conn: Connection) -&gt; None:\n        self._captured_expressions.append(SQLExpression(executable=text(\"ROLLBACK\")))\n\n    def _on_after_execute(\n        self,\n        conn: Connection,\n        clauseelement: Executable,\n        multiparams: list[dict[str, Any]],\n        params: dict[str, Any],\n        execution_options: Mapping[str, Any],\n        result: CursorResult,\n    ) -&gt; None:\n        self._captured_expressions.append(\n            SQLExpression(executable=clauseelement, params=params, multiparams=multiparams)\n        )\n\n    def __enter__(self) -&gt; Self:\n        events_stack = self._sqlaclhemy_events_stack.__enter__()\n\n        for event_name, listener in (\n            (\"begin\", self._on_begin),\n            (\"commit\", self._on_commit),\n            (\"rollback\", self._on_rollback),\n            (\"after_execute\", self._on_after_execute),\n        ):\n            events_stack.enter_context(\n                temp_sqlalchemy_event(\n                    self._engine.sync_engine,\n                    event_name,\n                    listener,\n                )\n            )\n\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[type[BaseException]],\n        exc_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; Optional[bool]:\n        return self._sqlaclhemy_events_stack.__exit__(exc_type, exc_value, traceback)\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.context.SQLAlchemyCaptureContext.captured_expressions","title":"captured_expressions  <code>property</code>","text":"<pre><code>captured_expressions: list[SQLExpression]\n</code></pre> <p>Returns all SQL expressions captured in the current context.</p>"},{"location":"api-reference/#pytest_capsqlalchemy.context.SQLAlchemyCaptureContext.__init__","title":"__init__","text":"<pre><code>__init__(engine: AsyncEngine)\n</code></pre> <p>Create a new SQLAlchemyCaptureContext instance.</p> Source code in <code>pytest_capsqlalchemy/context.py</code> <pre><code>def __init__(self, engine: AsyncEngine):\n    \"\"\"Create a new SQLAlchemyCaptureContext instance.\"\"\"\n    self._engine = engine\n    self._captured_expressions = []\n    self._sqlaclhemy_events_stack = contextlib.ExitStack()\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.context.SQLAlchemyCaptureContext.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all SQL expressions captured so far in the current context.</p> Source code in <code>pytest_capsqlalchemy/context.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all SQL expressions captured so far in the current context.\"\"\"\n    self._captured_expressions = []\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.expression.SQLExpressionType","title":"SQLExpressionType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enumeration of the different types of SQL expressions that can be captured.</p> Source code in <code>pytest_capsqlalchemy/expression.py</code> <pre><code>class SQLExpressionType(str, enum.Enum):\n    \"\"\"An enumeration of the different types of SQL expressions that can be captured.\"\"\"\n\n    SELECT = \"SELECT\"\n    INSERT = \"INSERT\"\n    UPDATE = \"UPDATE\"\n    DELETE = \"DELETE\"\n    BEGIN = \"BEGIN\"\n    COMMIT = \"COMMIT\"\n    ROLLBACK = \"ROLLBACK\"\n    UNKNOWN = \"UNKNOWN\"\n\n    @property\n    def is_tcl(self) -&gt; bool:\n        \"\"\"Check if the SQL expression type is a transaction control language statement.\"\"\"\n        return self in {SQLExpressionType.BEGIN, SQLExpressionType.COMMIT, SQLExpressionType.ROLLBACK}\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.expression.SQLExpressionType.is_tcl","title":"is_tcl  <code>property</code>","text":"<pre><code>is_tcl: bool\n</code></pre> <p>Check if the SQL expression type is a transaction control language statement.</p>"},{"location":"api-reference/#pytest_capsqlalchemy.expression.SQLExpression","title":"SQLExpression  <code>dataclass</code>","text":"<p>A representation of a single SQL expression captured by SQLAlchemy.</p> <p>Stores the SQLAlchemy <code>Executable</code> object and any parameters used in the query, so that it can be compared against expected queries in tests. This is useful for performing specific assertions on the captured expressions which cannot be easily achieved with the provided assert methods.</p> Source code in <code>pytest_capsqlalchemy/expression.py</code> <pre><code>@dataclass\nclass SQLExpression:\n    \"\"\"A representation of a single SQL expression captured by SQLAlchemy.\n\n    Stores the SQLAlchemy `Executable` object and any parameters used in the query, so that it can be\n    compared against expected queries in tests. This is useful for performing specific assertions\n    on the captured expressions which cannot be easily achieved with the provided assert methods.\n    \"\"\"\n\n    executable: Executable\n    params: dict[str, Any] = field(default_factory=dict)\n    multiparams: list[dict[str, Any]] = field(default_factory=list)\n\n    def get_sql(self, *, bind_params: bool = False) -&gt; str:\n        \"\"\"Get the SQL string generated by SQLAlchemy of the captured expression.\n\n        Args:\n            bind_params: If True, the SQL string will include the bound parameters in the query. Otherwise the\n                SQL string will contain placeholders for the bound parameters.\n\n        Returns:\n            The SQL string of the captured expression\n        \"\"\"\n        assert isinstance(self.executable, ClauseElement)\n\n        if self.executable.is_insert:\n            assert isinstance(self.executable, Insert)\n\n            if self.multiparams:\n                expr = self.executable.values(self.multiparams)\n            elif self.params:\n                expr = self.executable.values(self.params)\n            else:\n                expr = self.executable\n        else:\n            expr = self.executable\n\n        compile_kwargs = {}\n        if bind_params:\n            compile_kwargs[\"literal_binds\"] = True\n\n        return str(expr.compile(compile_kwargs=compile_kwargs))\n\n    @property\n    def type(self) -&gt; SQLExpressionType:\n        \"\"\"Get the type of the captured SQL expression.\"\"\"\n        if self.executable.is_insert:\n            return SQLExpressionType.INSERT\n\n        if self.executable.is_select:\n            return SQLExpressionType.SELECT\n\n        if self.executable.is_update:\n            return SQLExpressionType.UPDATE\n\n        if self.executable.is_delete:\n            return SQLExpressionType.DELETE\n\n        if isinstance(self.executable, TextClause):\n            if self.executable.compare(text(\"BEGIN\")):\n                return SQLExpressionType.BEGIN\n\n            if self.executable.compare(text(\"COMMIT\")):\n                return SQLExpressionType.COMMIT\n\n            if self.executable.compare(text(\"ROLLBACK\")):\n                return SQLExpressionType.ROLLBACK\n\n        return SQLExpressionType.UNKNOWN\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.expression.SQLExpression.type","title":"type  <code>property</code>","text":"<pre><code>type: SQLExpressionType\n</code></pre> <p>Get the type of the captured SQL expression.</p>"},{"location":"api-reference/#pytest_capsqlalchemy.expression.SQLExpression.get_sql","title":"get_sql","text":"<pre><code>get_sql(*, bind_params: bool = False) -&gt; str\n</code></pre> <p>Get the SQL string generated by SQLAlchemy of the captured expression.</p> <p>Parameters:</p> Name Type Description Default <code>bind_params</code> <code>bool</code> <p>If True, the SQL string will include the bound parameters in the query. Otherwise the SQL string will contain placeholders for the bound parameters.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The SQL string of the captured expression</p> Source code in <code>pytest_capsqlalchemy/expression.py</code> <pre><code>def get_sql(self, *, bind_params: bool = False) -&gt; str:\n    \"\"\"Get the SQL string generated by SQLAlchemy of the captured expression.\n\n    Args:\n        bind_params: If True, the SQL string will include the bound parameters in the query. Otherwise the\n            SQL string will contain placeholders for the bound parameters.\n\n    Returns:\n        The SQL string of the captured expression\n    \"\"\"\n    assert isinstance(self.executable, ClauseElement)\n\n    if self.executable.is_insert:\n        assert isinstance(self.executable, Insert)\n\n        if self.multiparams:\n            expr = self.executable.values(self.multiparams)\n        elif self.params:\n            expr = self.executable.values(self.params)\n        else:\n            expr = self.executable\n    else:\n        expr = self.executable\n\n    compile_kwargs = {}\n    if bind_params:\n        compile_kwargs[\"literal_binds\"] = True\n\n    return str(expr.compile(compile_kwargs=compile_kwargs))\n</code></pre>"},{"location":"api-reference/#pytest_capsqlalchemy.utils.temp_sqlalchemy_event","title":"temp_sqlalchemy_event","text":"<pre><code>temp_sqlalchemy_event(\n    target: Any,\n    identifier: str,\n    fn: Callable[..., Any],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Temporarily add a SQLAlchemy event listener to the target object.</p> <p>The event listener is automatically removed when the context manager exits.</p> Source code in <code>pytest_capsqlalchemy/utils.py</code> <pre><code>@contextlib.contextmanager\ndef temp_sqlalchemy_event(\n    target: Any,\n    identifier: str,\n    fn: Callable[..., Any],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Generator[None, None, None]:\n    \"\"\"Temporarily add a SQLAlchemy event listener to the target object.\n\n    The event listener is automatically removed when the context manager exits.\n    \"\"\"\n    event.listen(target, identifier, fn, *args, **kwargs)\n\n    try:\n        yield\n    finally:\n        event.remove(target, identifier, fn)\n</code></pre>"}]}